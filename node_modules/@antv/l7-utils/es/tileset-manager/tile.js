import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import bboxPolygon from '@turf/bbox-polygon';
import { LoadTileDataStatus } from './types';
import { getTileWarpXY, tileToBounds } from './utils/lonlat-tile';
export var Tile = function () {
  function Tile(options) {
    _classCallCheck(this, Tile);

    _defineProperty(this, "x", void 0);

    _defineProperty(this, "y", void 0);

    _defineProperty(this, "z", void 0);

    _defineProperty(this, "tileSize", 256);

    _defineProperty(this, "isVisible", false);

    _defineProperty(this, "isCurrent", false);

    _defineProperty(this, "layer", null);

    _defineProperty(this, "layers", []);

    _defineProperty(this, "parent", null);

    _defineProperty(this, "children", []);

    _defineProperty(this, "data", null);

    _defineProperty(this, "properties", {});

    _defineProperty(this, "loadStatus", void 0);

    _defineProperty(this, "abortController", void 0);

    _defineProperty(this, "loadDataId", 0);

    var x = options.x,
        y = options.y,
        z = options.z,
        tileSize = options.tileSize;
    this.x = x;
    this.y = y;
    this.z = z;
    this.tileSize = tileSize;
  }

  _createClass(Tile, [{
    key: "isLoading",
    get: function get() {
      return this.loadStatus === LoadTileDataStatus.Loading;
    }
  }, {
    key: "isLoaded",
    get: function get() {
      return this.loadStatus === LoadTileDataStatus.Loaded;
    }
  }, {
    key: "isCancelled",
    get: function get() {
      return this.loadStatus === LoadTileDataStatus.Cancelled;
    }
  }, {
    key: "isDone",
    get: function get() {
      return [LoadTileDataStatus.Loaded, LoadTileDataStatus.Cancelled, LoadTileDataStatus.Failure].includes(this.loadStatus);
    }
  }, {
    key: "bounds",
    get: function get() {
      return tileToBounds(this.x, this.y, this.z);
    }
  }, {
    key: "bboxPolygon",
    get: function get() {
      var _this$bounds = _slicedToArray(this.bounds, 4),
          minLng = _this$bounds[0],
          minLat = _this$bounds[1],
          maxLng = _this$bounds[2],
          maxLat = _this$bounds[3];

      var center = [(maxLng - minLng) / 2, (maxLat - minLat) / 2];
      var polygon = bboxPolygon(this.bounds, {
        properties: {
          key: this.key,
          bbox: this.bounds,
          center: center,
          meta: "\n      ".concat(this.key, "\n      ")
        }
      });
      return polygon;
    }
  }, {
    key: "key",
    get: function get() {
      var key = "".concat(this.x, ",").concat(this.y, ",").concat(this.z);
      return key;
    }
  }, {
    key: "loadData",
    value: function () {
      var _loadData = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(_ref) {
        var getData, onLoad, onError, loadDataId, tileData, error, x, y, z, bounds, tileSize, _getTileWarpXY, warpX, warpY, signal, params;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                getData = _ref.getData, onLoad = _ref.onLoad, onError = _ref.onError;
                this.loadDataId++;
                loadDataId = this.loadDataId;

                if (this.isLoading) {
                  this.abortLoad();
                }

                this.abortController = new AbortController();
                this.loadStatus = LoadTileDataStatus.Loading;
                tileData = null;
                _context.prev = 7;
                x = this.x, y = this.y, z = this.z, bounds = this.bounds, tileSize = this.tileSize;
                _getTileWarpXY = getTileWarpXY(x, y, z), warpX = _getTileWarpXY.warpX, warpY = _getTileWarpXY.warpY;
                signal = this.abortController.signal;
                params = {
                  x: warpX,
                  y: warpY,
                  z: z,
                  bounds: bounds,
                  tileSize: tileSize,
                  signal: signal
                };
                _context.next = 14;
                return getData(params);

              case 14:
                tileData = _context.sent;
                _context.next = 20;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](7);
                error = _context.t0;

              case 20:
                if (!(loadDataId !== this.loadDataId)) {
                  _context.next = 22;
                  break;
                }

                return _context.abrupt("return");

              case 22:
                if (!(this.isCancelled && !tileData)) {
                  _context.next = 24;
                  break;
                }

                return _context.abrupt("return");

              case 24:
                if (!(error || !tileData)) {
                  _context.next = 28;
                  break;
                }

                this.loadStatus = LoadTileDataStatus.Failure;
                onError(error, this);
                return _context.abrupt("return");

              case 28:
                this.loadStatus = LoadTileDataStatus.Loaded;
                this.data = tileData;
                onLoad(this);

              case 31:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 17]]);
      }));

      function loadData(_x) {
        return _loadData.apply(this, arguments);
      }

      return loadData;
    }()
  }, {
    key: "reloadData",
    value: function reloadData(params) {
      if (this.isLoading) {
        this.abortLoad();
      }

      this.loadData(params);
    }
  }, {
    key: "abortLoad",
    value: function abortLoad() {
      if (this.isLoaded || this.isCancelled) {
        return;
      }

      this.loadStatus = LoadTileDataStatus.Cancelled;
      this.abortController.abort();
    }
  }]);

  return Tile;
}();
//# sourceMappingURL=tile.js.map